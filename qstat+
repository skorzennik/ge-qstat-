#!/usr/bin/perl -w
#
# <- Last updated: Mon Jul  1 13:20:31 2024 -> SGK
#
# PERL script to parse output of SGE's qstat 
#   uses qstat's -xlm output
#
use strict;
#
my $VERSION = 'qstat+: Ver 5.5/2 - Jun 2024';
#
# ------------------------------------------------------------------------
#
# list of nodes: head node, login nodes, NSDs
#
my @logNames = qw/hydra-7 login01 login02 login04 login07/;
my @nsdNames = qw/nsd01 nsd02/;
my $nodePrfx = 'compute-';
#
# list of queues to show - all.q is ignored
#
my @queueSet = ('sThC.q', 'mThC.q', 'lThC.q', 'uThC.q', '', 
                'sThM.q', 'mThM.q', 'lThM.q', 'uThM.q', '',
                'uTxlM.rq', '',
                'lTIO.sq', '',
                'sTgpu.q','mTgpu.q', 'lTgpu.q', '',
                'qgpu.iq', 'qrsh.iq', 
    );
#
# queue to ignore, this can be a RE since it is used as if ($queue !~ /$ignQueue/)
my $ignQueue = 'all.q'; 
#
# type of GE implementation: SGE or UGE/AGE
#
my $geType = 'sge';
my $qstat = "qstat";
if (defined $ENV{SGE_ROOT}) {
  $qstat = "$ENV{SGE_ROOT}/bin/$ENV{SGE_ARCH}/$qstat";
  if ($ENV{SGE_ROOT} =~ /\/uge\//) {
    $geType = 'uge';
  }
} else {
  $geType = 'uge';
}
#
# use ruptime or ssh $host uptime?
#
my $uptimeCommand = '/usr/bin/ruptime -n=25';
# my $uptimeCommand = 'uptime';
#
# ------------------------------------------------------------------------
#
# what to show
#
my %show = ('running'  => 0,
            'queued'   => 0,
            'others'   => 0,
            'header'   => 1,
            'footer'   => 1,
            'age'      => 0,
            'cpu'      => 0,
            'user'     => 1,
            'mem'      => 0,
            'load'     => 0,
            'u/a'      => 0,
            'start'    => 0,
            'io'       => 0,
            'iow'      => 0,
            'ioops'    => 0,
            'license'  => 1,
            'ineff'    => 0,
            'osub'     => 0,
            'raw'      => 0,
            'warn'     => 0,
            'sfmt'     => 0 );
#
# options
#
my %option = ('fake'    => 0,
              'cntPE'   => 0,
              'mode'    => 'userlist', 
              'verbose' => 0,
              'wide'    => 0,
              'sort'    => 'jid',
              'esx'     => 0,
              'notty'   => 0,
              'user'    => "'*'",
              'ineffT'  =>  33,
              'osubT'   => 133,
              'osubE'   =>   0,
              'oresF'   => 2.5,
              'ageT'    =>   1,
              'uptime'  =>  $uptimeCommand,
              'limit'   => '');
# args
my %args = (
  # modes
  '-s'        => 'o:mode=summary',
  '-sx'       => 'o:mode=summary,s:sfmt=1',
  '-sc'       => 'o:mode=summary,s:sfmt=2',
  '-a'        => 'o:mode=showa',
  '-q'        => 'o:mode=showq',
  '-r'        => 'o:mode=showr',
  '-X'        => 'o:mode=showX',
  '-j'        => 'o:mode=jid,o:jidList=NEXT',
  '-gc'       => 'o:mode=gc',
  '-es'       => 'o:mode=es',
  '-esx'      => 'o:mode=es,o:esx=1',
  '-osub'     => 'o:mode=showr,s:osub=1,s:cpu=2,s:age=1,s:header=1,s:footer=0,o:user=$USER',
  '-ineff'    => 'o:mode=showr,s:ineff=1,s:cpu=2,s:age=1,s:header=1,s:footer=0,o:user=$USER',
  '-ores'     => 'o:mode=showr,s:ores=1,s:mem=3,s:cpu=2,s:age=1,s:header=1,s:footer=0,o:user=$USER',
  '-oresF'    => 'o:oresF=NEXT',
  '-osubT'    => 'o:osubT=NEXT',
  '-osubE'    => 'o:osubE=NEXT',
  '-ineffT'   => 'o:ineffT=NEXT',
  '-ageT'     => 'o:ageT=NEXT',
  '-nlist'    => 'o:mode=nodelist,o:jidList=NEXT',
  '-hiload'   => 'o:mode=hiload,o:offset=NEXT',
  '-down'     => 'o:mode=down',
  '-ssd'      => 'o:mode=ssd',
  '-h'        => 'o:mode=help',
  '-help'     => 'o:mode=help',
  '--help'    => 'o:mode=help',
  '-examples' => 'o:mode=examples',
  # options
  '-v'     => 'o:verbose=1',
  '-verbose' => 'o:verbose=1',
  '-warn'  => 's:warn=1',
  '-u'     => 'o:user=NEXT',
  '-queue' => 'o:queue=NEXT',
  '-wide'  => 'o:wide=1',
  '-notty' => 'o:notty=1',
  '-npes'  => 'o:cntPE=1',
  '-nqpe'  => 'o:cntPE=2',
  '-nqxx'  => 'o:cntPE=4',
  '-njobs' => 'o:cntPE=-1',
  '-check-load' => 'o:check-load=1',
  # show
  '-load'  => 's:load=1',
  '-sua'   => 's:u/a=1',
  '+lic'      => 's:license=1',
  '-lic'      => 's:license=0',
  '-age'      => 's:age=1',
  '-cpu'      => 's:cpu=1',
  '-cpu%'     => 's:cpu=2',
  '-cpur'     => 's:cpu=3',
  '-io'       => 's:io=1',
  '-iow'      => 's:iow=1',
  '-ioops'    => 's:ioops=1',
  '-mem'      => 's:mem=1',
  '-memx'     => 's:mem=2',
  '-memr'     => 's:mem=3',
  '-noheader' => 's:header=0',
  '-nofooter' => 's:footer=0',
  '-raw'      => 's:raw=1',
  # shorthands
  '+a'        => 'x:-a -u $USER -nofooter', 
  '+a%'       => 'x:-a -u $USER -nofooter -age -cpu%',
  '+ax%'      => 'x:-a -u $USER -nofooter -age -cpu% -load -sua -mem -io',
  '+ar%'      => 'x:-a -u $USER -nofooter -age -cpu% -memr -io',
  '+r'        => 'x:-r -u $USER -nofooter',
  '+r%'       => 'x:-r -u $USER -nofooter -age -cpu%',
  '+rx%'      => 'x:-r -u $USER -nofooter -age -cpu% -load -sua -memx -io -iow -ioops',
  '+rr%'      => 'x:-r -u $USER -nofooter -age -cpu% -memr -io -iow -ioops',
  '+q'        => 'x:-q -u $USER -nofooter',
  '+q%'       => 'x:-q -u $USER -nofooter -age',
  '+qx%'      => 'x:-q -u $USER -nofooter -age -mem ',
  '+X'        => 'x:-X -u $USER -nofooter',
  '+n'        => 'x:-notty -wide -noheader -nofooter',
  # debug using files/fake, comment it out for production
  '-debug'  => 'o:fake=NEXT',
  '-geType' => 'o:geType=NEXT',
);
#
my @ERRMSG = ('use qstat+ -help to get usage',
              '    qstat+ -examples to see examples', '',
              $VERSION,
              '');
#
my @HELP = ('usage: qstat+ [mode] [options]',
            '  where modes are (exclusive list):', 
            '    -s|-sx|-sc      show summary (simple, extended or compact)',
            '    -a              show all jobs',
            '    -q              show queued jobs',
            '    -r              show running jobs',
            '    -X              show extra jobs (dr, Eqw, t)',
            '    -j      JID     show info on a specific (set of) job(s)',
            '    -nlist  JID     show node list for a (set of) job(s)',
            '                    use job.task to specify a task number, list of JIDs must be comma separated',
            '    -hiload N       show node(s) with high load',
            '    -gc             show global cluster status',
            '    -es[x]          show empty slots, -esx: expanded info',
            '    -down           show node(s) that are down',
            '    -ores           show overreserved jobs, i.e.: resMem/maxVMem > '.$option{'oresF'}.', & age > '.$option{'ageT'}.' hr',
            '    -osub           show oversubscribed jobs, i.e.: cpu% > '.$option{'osubT'}.'%, & age > '.$option{'ageT'}.' hr',
            '    -ineff          show inefficient jobs, i.e.: cpu% < '.$option{'ineffT'}.'%, & age > '.$option{'ageT'}.' hr',
            '    -ssd            show SSD usage',
            '    -h|-help--help  show help',
            '    -examples       show examples',
            '',
            'where options are:', 
            '    -u USER       limit to the specified user, you can use "*" or "all" to list everybody\'s jobs',
            '                  or a coma-separated list',
            '    -njobs        show counts in no. of jobs',
            '    -npes         show counts in no. of PEs (slots)',
            '    -nqpe         show jobs/PEs not jobs/tasks for queued jobs',
            '    -nqxx         show jobs/tasks/PEs for queued jobs',
            '    -load         show the nodes\' load',
            '    -sua          show the nodes\' used/avail no of slots',
            '    -age          show the age of the jobs, i.e., elapsed time vs starting/submit time',
            '    -cpu          show the amount of CPU used by running job(s)',
            '    -cpu%         show the amount of CPU/age/#PE in % (job efficiency)',
            '    -cpur         show the ratio CPU/AGE, not scaled by #PE', 
            '    -mem          show the mean memory usage for running jobs, the total requested memory for queued jobs, in GB',
            '    -memx         show more memory info for running jobs: reserved, mean, vmem and maxvmem (slow)',
            '    -memr         show more memory info for running jobs: reserved, mean, maxvmem and res/mxvmem (slow)',
            '    -io           show the I/O usage',
            '    -iow          show the I/O wait usage (slow)',
            '    -ioops        show the IOPs usage (slow)',
            '    +lic          show license info (default), although not in detailed outputs',
            '    -lic          do not show license info',
            '',
            '    -noheader     do not show the header',
            '    -nofooter     do not show the footer',
            '    -raw          print raw values (for easier parsing)',
            '    -queue QSPEC  limit to jobs in queue QSPEC (RE ok)',
            '    -oresF  VAL   change the overreserved factor to VAL',       
            '    -osubT  VAL   change the oversubscribed threshold to VAL, in %',       
            '    -osubE  VAL   set the oversubscribtion excess threshold to VAL, in hr x slots',       
            '    -ineffT VAL   change the inefficient threshold to VAL, in %',
            '    -ageT   VAL   change the minimum age threshold to VAL, in hour',
            '',
            '    -v|-verbose   set verbose mode',
            '    -warn         show warnings',
            '    -wide         wide output (132 cols, implies -notty)',
            '    -notty        do not use the width of the terminal, as returned by stty',
            '    -check-load   check the instantanous load (-hiload only)',          
            '',
            'shorthands:',
            '    +a   is expanded to -a -u $USER -nofooter             show all your jobs', 
            '    +a%                 -a -u $USER -nofooter -age -cpu%  ibidem, with cpu on % of age',
            '    +ax%                -a -u $USER -nofooter -age -cpu% -load -sua -mem -io',
            '    +ar%                -a -u $USER -nofooter -age -cpu% -memr -io',
            '    +r                  -r -u $USER -nofooter             show all your running jobs',
            '    +r%                 -r -u $USER -nofooter -age -cpu%  ibidem, with cpu on % of age',
            '    +rr%                -r -u $USER -nofooter -age -cpu% -memr -io -iow -ioops',
            '    +rx%                -r -u $USER -nofooter -age -cpu% -load -sua -memx -io -iow -ioops',
            '    +q                  -q -u $USER -nofooter             show all your queued jobs',
            '    +q%                 -q -u $USER -nofooter -age        ibidem but show age',
            '    +qx%                -q -u $USER -nofooter -age -mem   ibidem plus mem info',
            '    +X                  -X -u $USER -nofooter             show all your extra jobs',
            '    +n                  -notty -wide -noheader -nofooter',
            '',
            '    -debug DIR      read files from DIR to debug', 
            '    -geType sge|uge test that type of GE', '',
            $VERSION,
            '');
my @EXAMPLES = ('examples:',
                ' qstat+ -a -u hpc                   show all of hpc\'s jobs',
                ' qstat+ -r -cpu% -u hpc             show all of hpc\'s running jobs, cpu in %',
                ' qstat+ -r -cpu% -load -sua -u hpc  show all of hpc\'s running jobs, cpu in %, and',
                '                                the nodes\' load and slot usage/availability',
                ' qstat+ -q                          show all the queued jobs',
                ' qstat+ -j 8683280,8683285          show info on specific job IDs',
                ' qstat+ -nlist 8683280,8683285      show nodes list for specific job IDs',
                ' qstat+ -hiload 1.5                 show nodes whose load is 1.5 greater than the number of slots used',
                ' qstat+ -ineffT 50 -ineff           show jobs that are below a 50% efficiency threshold',
                ' qstat+ -osubT 200 -ageT 48 -osub   show jobs that are above a 200% usage threshold and are older than 48 hours',
                ' qstat+ -gc                         show the global cluster status',
                ' qstat+ -es                         show the empty slots',
                ' qstat+ -down                       show which nodes are down',
                '',
                '        +ax% -u all                 is equiv to -a -u all -cpu% -load -sua -mem',
                '                             etc... for the +XXX shorthands',
                '',
                $VERSION,
                '');
my $saveCmd = '';
my $saveLines;
#
my %timeThen;
my %hashJListTable = ();
my %hashQListTable = ();
#
$timeThen{main} = time();
#
# Parse arguments
#
&ParseArgs();
#
if      ($option{'mode'} eq 'help') {
    print STDERR join("\n", @HELP);
  exit();
} elsif ($option{'mode'} eq 'examples') {
  print STDERR join("\n", @EXAMPLES);
  exit();
} elsif ($option{'mode'} eq 'showa') {
  $show{running} = 1;
  $show{queued}  = 1;
  $show{others}  = 1;
  $option{'mode'} = 'showDetails';
} elsif ($option{'mode'} eq 'showq') {
  $show{running} = 0;
  $show{queued}  = 1;
  $option{'mode'} = 'showDetails';
} elsif ($option{'mode'} eq 'showr') {
  $show{running} = 1;
  $show{queued}  = 0;
  $option{'mode'} = 'showDetails';
} elsif ($option{'mode'} eq 'showX') {
  $show{others} = 1;
  $option{'mode'} = 'showDetails';
}
#
if ($option{'user'} eq 'all' || $option{'user'} eq  '*') {
  $option{'user'} = "'*'";
}
#
if ($option{'geType'}) {$geType = $option{'geType'}}
if ($option{'verbose'}) {
  my $key;
  print STDERR "qstat+: -verbose geType = $geType\n";
  print STDERR "qstat+: -verbose option: ";
  foreach $key (sort(keys(%option))) {
    print STDERR " $key=$option{$key}";
  }
  print STDERR "\n";
  print STDERR "qstat+: -verbose show:    ";
  foreach $key (sort(keys(%show))) {
    print STDERR " $key=$show{$key}";
  }
  print STDERR "\n";
}
#
my  $q_load_avg = 'q_load_avg';
my  $nodeExt    = 'local';
if ($geType eq 'uge') {
  $q_load_avg = 'q_np_load_avg';
  $nodeExt    = 'cm.cluster';
}
#
# Run different modes
#
if ($option{'mode'} eq 'jid') {
  #
  my @jidx = split(',', $option{'jidList'});
  #
  foreach my $jidx (@jidx) {
    my ($jid, $tid) = split('\.', $jidx);
    $option{'jid'} = $jid;
    $option{'tid'} = $tid;
    my @out  = &ExecQstat('J');
    #
    if ($#jidx > 0) {
      print " --- $jidx --- \n";
    }
    #
    &ShowJstat(@out);
  }
  #
} elsif ($option{'mode'} eq 'nodelist') {
  #
  my @outF  = &ExecQstat('F');
  my @fVals = &ParseQstat(@outF);
  #
  &ShowNodeList(@fVals);
  #
} elsif ($option{'mode'} eq 'gc') {
  #
  my @outF  = &ExecQstat('F');
  my @fVals = &ParseQstat(@outF);
  #
  &ShowClusterStats(@fVals);
  #
} elsif ($option{'mode'} eq 'es') {
  #
  my @outF  = &ExecQstat('F');
  my @fVals = &ParseQstat(@outF);
  #
  &ShowEmptySlots($option{esx}, @fVals);
  #
} elsif ($option{'mode'} eq 'hiload') {
  #
  my @outF  = &ExecQstat('F');
  my @fVals = &ParseQstat(@outF);
  #
  &ShowHiLoad(@fVals);
  #
} elsif ($option{'mode'} eq 'down') {
  #
  my @outF  = &ExecQstat('F');
  my @fVals = &ParseQstat(@outF);
  &ShowDown(@fVals);
  #
} elsif ($option{'mode'} eq 'showDetails') {
  #
  my @outR  = &ExecQstat('R');
  my @outF  = &ExecQstat('F');
  #
  my @rVals = &ParseQstat(@outR);
  my @fVals = &ParseQstat(@outF);
  #
  &ShowDetails(\@rVals, \@fVals);
  #
} elsif ($option{'mode'} eq 'userlist') {
  #
  my @outR  = &ExecQstat('R');
  my @outF  = &ExecQstat('F');
  #
  my @rVals = &ParseQstat(@outR);
  my @fVals = &ParseQstat(@outF);
  #
  &ShowUserList(\@rVals, \@fVals);
  #
} elsif ($option{'mode'} eq 'summary') {
  #
  my @outR  = &ExecQstat('R');
  my @outF  = &ExecQstat('F');
  #
  my @rVals = &ParseQstat(@outR);
  my @fVals = &ParseQstat(@outF);
  #
  &ShowSummary(\@rVals, \@fVals);
  #
} elsif ($option{'mode'} eq 'ssd') {
  my @out  = &ExecQstat('S');
  &ShowSSDUsage(\@out);
} else { 
  #
  die("Internal error: code should never get here (mode=$option{'mode'})");
}
#
if ($option{verbose}) {
  my $elapsedTime = time() - $timeThen{main};
  print STDERR "qstat+: all done in $elapsedTime sec\n";
}
exit;
#
# ---------------------------------------------------------------------------
#
# Routines
#
# sub ParseArgs    - parse the arguments
# sub ExecQstat    - execute qstat -xml [options]
# sub ParseQstat   - parse the output of qstat -xml
# sub CompileStats - Compile cluster stats
# ---
# sub ShowDetails      - show details
# sub ShowJstat        - show job stats
# sub ShowNodeList     - show node lisy
# sub ShowEmptySlots   - show empry slots
# sub ShowClusterStats - show cluster stats
# sub ShowDown         - show nodes down
# sub ShowHiLoad       - show nodes with excessive load
# sub ShowUserList     - show list of users
# sub ShowSSDUsage     - show SSD usage
# sub ShowHeader       - show header
# sub ShowFooter       - show footer
# sub ShowSummary      - show summary
# sub ShowQState       - show queue stats
# ---
# sub FmtIOW           - format IOW
# sub FmtIOOps
# sub FmtIOUse
# sub CvtSSD
# sub FmtSSD
# ---
# sub Load
# sub UseAvail
# sub SubStartTime
# sub CvtTime
# sub FormatTime
# sub Age
# sub Total
# sub XVals
# ---
# sub GetValJList
# sub GetValQList
# sub GetNodeNumber
# sub GetJobInfo
# sub GetVMem
# sub GetMaxVMem
# sub GetIOWait
# sub GetIOOPs
# ---
# sub Uptime
# sub bynode
# ---
#
# ------------------------------------------------------------------------
#
sub ParseArgs {
  #
  #
  #
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  my %set = ();
  my $err = 0;
  #
  while ($#ARGV >= 0) {
    if ($set{$ARGV[0]}) {
      if ($show{warn}) {
        print STDERR 'qstat+: ParseArgs() warning duplicate argument "'.$ARGV[0].'"'."\n";
      }
      # $err++;
      # goto nextArg;
    } 
    #
    $set{$ARGV[0]}++;
    foreach my $key (keys %args) {
      if ($ARGV[0] eq $key) {
        foreach my $val (split(',', $args{$key})) {
          my ($t, $a) = split(':', $val);
          my ($k, $v) = split('=', $a);
          #
          my $ign = 0;
          if ($set{$k}) {
          # qstat+: ParseArgs() argument "-u" conflicts with "-osub" (user)
            if ($k eq 'user') {
              if ($set{$k} eq '-osub'  || 
                  $set{$k} eq '-ineff' ||
                  $set{$k} eq '-ores' ) { $ign = 1;}
            }
            if ($set{$k} ne $key && $ign == 0) {
              #
              $err++;
              print STDERR 'qstat+: ParseArgs() argument "'.$ARGV[0].'"'.' conflicts with "'.$set{$k}.'"'." ($k)\n";
            }
          }
          $set{$k} = $key;
          #
          if ($t eq 'o') {     
            #
            if ($v eq 'NEXT') {
              shift @ARGV;
              if ($#ARGV >= 0) {
                $option{$k} = $ARGV[0];
              } else {
                $err++;
                print STDERR 'qstat+: ParseArgs() incomplete "'.$key.'" argument'."\n";
              }
            } else {
              $option{$k} = $v;
            }
            #
          } elsif ($t eq 's') {
            #
            $show{$k} = $v;
            #
          } elsif ($t eq 'x') {
            #
            my @w = split(' ', $a);
            my $w;
            my @l = ();
            #
            foreach $w (@w) {
              if ($w =~ /^\$/) {
                $w =~s/.//;
                $w = $ENV{$w};
              }
              @l = (@l, $w);
            }
            # splice @l in @ARGV
            $w = shift @ARGV;
            @ARGV = ($w, @l, @ARGV);
            #
            ## print STDERR join(':',@ARGV),"\n"; die "here";
          } else {
            #
            die "qstat+: ParseArgs() should not get here (t=$t)";
            #
          }
        }
        goto nextArg;
      }
    }
    $err++;
    print STDERR 'qstat+: ParseArgs() invalid argument "'.$ARGV[0].'"'."\n";
  nextArg:    
    shift @ARGV;
  }
  #
  if ($err > 0) {
    print STDERR join("\n", @ERRMSG);
    exit(1);
  }
  #
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR  "qstat+: ParseArgs() done in $elapsedTime sec\n";
  }
}
#
# ---------------------------------------------------------------------------
#
sub ExecQstat {
  #
  # execute qstat command
  #  
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  #
  my $mode = shift(@_);
  my $fn   = '';
  my $opts = '';
  my $cmd  = '';
  #
  if ($option{fake}) {
    if    ($mode eq 'R') {
      if ($option{user} ne "'*'") {
        $fn = $option{fake}.'/qstat-r-'.$option{user}.'.xml';
      } else {
        $fn = $option{fake}.'/qstat-r.xml';
      }
    }
    elsif ($mode eq 'F') {
      if ($option{user} ne "'*'") {
        $fn = $option{fake}.'/qstat-f-'.$option{user}.'.xml';
      } else {
        $fn = $option{fake}.'/qstat-f.xml';
      }
    }
    elsif ($mode eq 'J') {
      # use the 1st jobid from the list, and ignore .$tid if any
      my @jids = split(',',  $option{jidList});
      my ($jid, $tid) = split('\.', $jids[0]);
      $fn = $option{fake}.'/qstat-j-'.$jid.'.txt';
    }
    elsif ($mode eq 'S') { $fn = $option{fake}.'/qstat-ssd.txt'; }
    else {die "qstat+: ExecQstat(): invalid mode $mode\n"; }
    # 
    $cmd = 'cat '.$fn;
  } else {
    my $queue = '';
    if ($option{'queue'}) { $queue = " -q '$option{'queue'}'"; }
    if    ($mode eq 'R') { $opts = ' -xml -r -ext -u '.$option{'user'}.$queue; }
    elsif ($mode eq 'F') { $opts = ' -xml -f      -u '.$option{'user'}.$queue; }
    elsif ($mode eq 'J') { $opts = ' -j '.$option{'jid'}; }
    elsif ($mode eq 'S') { 
      #
      # don't bother to use -xml
      $opts = '-F ssd_res,ssd_free,ssd_total -q all.q@@ssd-hosts -u nobody';
    } else {die "qstat+: ExecQstat(): invalid mode $mode\n"; }
    $cmd = $qstat.' '.$opts;
  }
  #
  if ($option{verbose} || $option{fake}) {
    print STDERR "qstat+: ExecQstat(): executing <$cmd>";
    if (! $option{verbose}) { print STDERR "\n"; }
  }
  #
  my @lines = `$cmd`;
  if ($? != 0) {
    die "qstat+: ExecQstat(): command failed <$!>\n";
  }
  #
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR " done in $elapsedTime sec\n";
  }
  #
  return @lines;
  #
}
#
# ---------------------------------------------------------------------------
#
sub ParseQstat {
  #
  # the parsing should return a tree, not a list, but this will do for now
  #
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  #
  my $line  = '';
  my $tag   = '';
  my $val   = '';
  my $tagx  = '';
  my @opts  = ();
  my @tags  = ();
  my @info = ();
  my %info = ();
  #
  my %prfx = ('Queue-List' => 'q_',
              'job_list'   => 'j_');
  #
  # parsing xlm data. -> @info = ({%info})
  #
  my $iLine = 1;
  my $level = 0;
  my $prfx;
  #
  foreach $line (@_) {
    #
    if      ($line =~ /<\?xml .*\?\>/) { 
      #ignore
    } elsif ($line =~ /\<.*\>.*\<\/.*\>/) { 
      # <tag options>value</tag>
      $line =~ s/\<(.*)\>(.*)\<\/(.*)\>//;
      ($tag, @opts)  = split(' ', $1);
      $val  = $2;
      $tagx = $3;
      if ($tag ne $tagx) {
        die "qstat+: ParseQstat() error: $tag & $tagx do not match at line $iLine\n";
      }
      # parse opts for name="";
      foreach my $opt (@opts) {
        my ($k, $v) = split('=', $opt);
        if ($k eq 'name') { 
          $v =~ s/^\"//;
          $v =~ s/\"$//;
          $tag .= '.'.$v; 
        }
      }
      #
      my $nTag = $#tags;
      $prfx = '';
      while ($prfx eq '') {
        if ($prfx{$tags[$nTag]}) {
          $prfx = $prfx{$tags[$nTag]};
        } else {
          $nTag--;
        }
      }
      #
      if ($prfx eq '') { die "qstat+: ParseQstat() error: invalid tag[$nTag]=$tags[$nTag]\n"; }
      #
      $info{$prfx.$tag} = $val;
      #
    } else {
      #
      # <tag options>
      $line =~ s/\<(.*)\>//;
      ($tag, @opts)  = split(' ', $1);
      if ($tag =~ /^\/.*/) {
        $level--;
        $tag =~ s/.//;
        $tagx = pop(@tags);
        if ($tag ne $tagx) {
          die "qstat+: ParseQstat() error: $tagx & /$tag do not match at line $iLine\n";
        }
        #
        if ($tag eq 'job_list' || $tag eq 'Queue-List') {
          #
          my $n = keys(%info);
          if ($n > 0) {
            #
            # UGE --> load *= n_slots
            if ($geType eq 'uge') {
              if (defined $info{$q_load_avg}) {
                $info{$q_load_avg} *= $info{q_slots_total};
              }
            }
            @info = (@info, {%info});
            ###
            my $k = $prfx.'JB_job_number';
            if ($info{$k}) {
              $tag .= ' '.$info{$k};
            }
          }
          %info = ();
        }
        #
      } else {
        #
        # push the tag
        $level++;
        @tags = (@tags, $tag);
      }
      #
    }
    $iLine++;
  }
  #
  # done parsing the xml data
  #
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR "qstat+: ParseQstat() done in $elapsedTime sec\n";
  }
  return @info;
}
#
# ---------------------------------------------------------------------------
#
sub CompileStats {
  #
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  #
  # parsing these licenses
  #
  my @lic = ('idlrt');
  #
  my @info  = @{$_[0]}; # qstat -r
  my @infox = @{$_[1]}; # qstat -f
  my $info  = '';
  #
  my %cntR  = ();
  my %cntRJ = ();
  my %cntQ  = ();
  my %cntQT = ();
  my %cntQJ = ();
  my %cntX  = ();
  my %cntXS = ();
  my %total = ();
  my %lic   = ();
  #
  my %info  = ();
  my $user  = '';
  my $state = '';
  #
  $total{slots}   = 0;
  $total{runPEs}  = 0;
  $total{runJobs} = 0;
  $total{queued}  = 0;
  $total{extra}   = 0;
  #
  $total{queues}  = '';
  $total{racks}   = '';
  #
  $total{slots_disabled} = 0;
  #
  foreach $info (@info) {
    %info  = %{$info};
    #
    $user  = $info{j_JB_owner};
    $state = $info{j_state};
    if ($state =~ /r$/) {
      my $nPE = 1;
      foreach my $pe ('granted_pe.mpich', 'granted_pe.mthread', 'granted_pe.orte') {
        if ($info{'j_'.$pe}) { $nPE = $info{'j_'.$pe}; }
      }
      $total{runJobs}++;
      $total{runPEs} += $nPE;
      
      $cntR{$user} += $nPE;
      $cntRJ{$user}++;
      # parse license info
      foreach my $lic (@lic) {
        my $key = 'j_hard_request.'.$lic.'_license';
        if ( $info{$key} ) {
          $lic{$lic} += $info{$key};
        }
      }
      #
    } elsif ($state eq 'qw' || $state eq 'hqw') {
      # get # slots and tasks info to compute requested PEs
      my $nPE = 1;
      my $nT  = 1;
      if ($info{j_slots}) { $nPE = $info{j_slots}; }
      if ($info{j_tasks}) { 
        if ($info{j_tasks} =~ /:/) {
          my ($i,$j, $k) = split('[\-\:]', $info{j_tasks});
          $nT = ($j - $i + 1)/$k; 
        }
        # total is slots*tasks
        $nPE *= $nT;
      }
      #
      $cntQ{$user}+= $nPE;
      $cntQT{$user}+= $nT;
      $cntQJ{$user}++;
      $total{queued}++;
      #
    } else  {
      $cntX{$user}++;
      $total{extra}++;
      $cntXS{$state}++;
    }
  }
  #
  my %list = ();
  my ($name, $queue, $host);
  #
  $total{down} = 0;
  my %qNode = ();
  my %qLoad = ();
  my %qSlot = ();
  my %qResv = ();
  my %qUsed = ();
  my %qDis  = ();
  my %qAtt  = ();
  my %qErr  = ();
  my %rNode = ();
  my %init = ();
  my %down = ();
  my ($c, $rack, $node);
  #
  foreach $info (@infox) {
    %info = %{$info};
    if ($info{q_name})  {
      $name = $info{q_name};
      ($queue, $host) = split('@', $name, 2);
      #
      $qNode{$queue}++;
      #
      if (defined $info{$q_load_avg}) {
        $qLoad{$queue} += $info{$q_load_avg};
        $qSlot{$queue} += $info{q_slots_total};
        $qResv{$queue} += $info{q_slots_resv};
        $qUsed{$queue} += $info{q_slots_used};
      }
      #
      $host = &GetNodeNumber($host);
      ($rack, $node) = split('-', $host);
      #
      my $enabled = 1;
      #
      if ($info{q_state}) { 
        # check queue state
        if ($info{q_state} =~ /d/) { $qDis{$queue}++; $enabled = 0; }
        if ($info{q_state} =~ /a/) { $qAtt{$queue}++; $enabled = 0; }
        if ($info{q_state} =~ /E/) { $qErr{$queue}++; $enabled = 0; }
      }
      #
      if ($list{$host}) {
        # don't count twice
      } else {
        #
        $rNode{$rack}++;
        $list{$host}++;
        if (defined $info{$q_load_avg}) {
          $total{load} += $info{$q_load_avg};
        } else {
          $total{down}++;
          $down{$host}++;
        }
        $total{nodes}++;
        if ($enabled == 1) {
          $total{slots} += $info{q_slots_total};  
        } else {
          $total{slots_disabled} += $info{q_slots_total};  
        }
      }
      $total{slotsUsed} += $info{q_slots_used};  
      #
    } else {
      # print join(', ', keys %info),"\n";
    }
  }
  #
  foreach $queue (sort keys %qNode) {
    # queue:load, noNodes,  nUsed(CPUs), nRes(CPUs), nCPUs(avail)
    if (! $qLoad{$queue}) {$qLoad{$queue} = 0.0;}
    if (! $qNode{$queue}) {$qNode{$queue} = 0;}
    if (! $qUsed{$queue}) {$qUsed{$queue} = 0;}
    if (! $qResv{$queue}) {$qResv{$queue} = 0;}
    if (! $qSlot{$queue}) {$qSlot{$queue} = 0;}
    $total{queues} .= "$queue:$qLoad{$queue},$qNode{$queue},$qUsed{$queue},$qResv{$queue},$qSlot{$queue} ";
  }
  chop($total{queues});
  #
  foreach $rack (sort keys %rNode) {
    $total{racks} .= "$rack/$rNode{$rack} ";
  }
  chop($total{racks});
  #
  $total{dis} = &Total(%qDis);
  $total{att} = &Total(%qAtt);
  $total{err} = &Total(%qErr);
  #
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR "qstat+: CompileStats() done in $elapsedTime sec\n";
  }
  #
  return (\%cntR, \%cntRJ, \%cntQ, \%cntQT, \%cntQJ, \%cntX, \%total, \%lic, \%cntXS, 
      \%qDis, \%qAtt, \%qErr, \%down);
  #
}
#
# ---------------------------------------------------------------------------
#
sub ShowDetails {
  #
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  #
  my @info  = @{$_[0]}; # qstat -r
  my @infox = @{$_[1]}; # qstat -f
  #
  my $info;
  my %info;
  #
  my %cntR;
  my %cntRJ;
  my %cntQ;
  my %cntQT;
  my %cntQJ;
  my %cntX;
  my %total;
  my %lic;
  my %cntXS;
# my %qDis;
# my %qAtt;
# my %qErr;
  #
  if ($show{header} == 1 || $show{footer} == 1 ) {
    #
    my @refs = &CompileStats(@_);
    #
    %cntR  = %{$refs[0]};
    %cntRJ = %{$refs[1]};
    %cntQ  = %{$refs[2]};
    %cntQT = %{$refs[3]};
    %cntQJ = %{$refs[4]};
    %cntX  = %{$refs[5]};
    %total = %{$refs[6]};
    %lic   = %{$refs[7]};
    #
    %cntXS = %{$refs[8]};
#   %qDis  = %{$refs[9]};
#   %qAtt  = %{$refs[10]};
#   %qErr  = %{$refs[11]};
  }
  #
  # ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time());
  my @now = localtime(time());
  @now = @now[(5,4,3,2,1,0)];
  $now[1]++;
  $now[0]+=1900;
  #
  ## my $sep = ' |';
  my $sep = '';
  my %keys = ('jobID'     => '9:d:JB_job_number', 
              'name'      => '-XX:.XXs:full_job_name', 
              'user'      => '-15:s:JB_owner', 
              'stat'      => '4:s:state', 
              'sub/start' => '-11:.11s:&SubStartTime', 
              'age'       => '7:s:&Age', 
              'cpuT'      => '7:s:&CpuT',
              'cpu'       => '7:.1f%%:&Cpu%',
              'cpu/age'   => '7:.4f:&CpuR',
              'memInfo'   => '7:.1f:&MemUse',
              'memMean'   => '8:.1f:&MemMean',
              'memRes'    => '8:.1f:&MemRes',
              'Res/MxVM'  => '8:.2f:&MemResX',
              'memVMem'   => '8:.1f:&MemVMem',
              'memMxVM'   => '8:.1f:&MemMxVMem',
              'ioUse'     => '8:s:&IOUse',
              'ioWait'    => '8:s:&IOWait',
              'ioOps'     => '8:s:&IOOPs',
              'nPEs'      => '4:d :slots', 
              'queue'     => '-8:s:&Queue',
              'node'      => '5:s:&Node',
              'load'      => '5:.1f:&Load',
              'u/a'       => '6:s:&UseAvail',
              'taskID'    => '6:s:tasks',

      );
  #
  # what to show: build the list
  my @itemList = ('jobID', 'name');
  #
  if ($option{user} eq "'*'" || $option{'user'} =~ /,/) {
    @itemList = (@itemList, 'user');
  }
  if ($show{running} == $show{queued}) {
    @itemList = (@itemList, 'stat');
  }
  if ($show{age}) {
    @itemList = (@itemList, 'age');
  } else {
    @itemList = (@itemList, 'sub/start');
  }
  @itemList = (@itemList, 'nPEs');

  if ($show{running} == 1) {
    if    ($show{cpu} == 1)   { @itemList = (@itemList, 'cpuT');  }
    elsif ($show{cpu} == 2)   { @itemList = (@itemList, 'cpu');  }
    elsif ($show{cpu} == 3)   { @itemList = (@itemList, 'cpu/age');  }
    if    ($show{mem} == 1)   { @itemList = (@itemList, 'memInfo');  }
    if    ($show{mem} == 2)   { @itemList = (@itemList, 'memRes', 'memMean', 'memVMem', 'memMxVM');  }
    if    ($show{mem} == 3)   { @itemList = (@itemList, 'memRes', 'memMean', 'memMxVM', 'Res/MxVM');  }
    if    ($show{io}  == 1)   { @itemList = (@itemList, 'ioUse');  }
    if    ($show{iow} == 1)   { @itemList = (@itemList, 'ioWait'); }
    if    ($show{ioops} == 1) { @itemList = (@itemList, 'ioOps');  }
                                @itemList = (@itemList, 'queue', 'node');
    if    ($show{load}  == 1) { @itemList = (@itemList, 'load');  }
    if    ($show{'u/a'} == 1) { @itemList = (@itemList, 'u/a');  }
  } else {
    if    ($show{mem} == 1)   { @itemList = (@itemList, 'memInfo');  }
    if    ($show{mem} == 2)   { @itemList = (@itemList, 'memRes');  }
    @itemList = (@itemList, 'queue');
  }

  @itemList = (@itemList, 'taskID');
  #
  my $h =  0;
  my $w = 80;
  if ($option{wide}) { 
    # -wide implies -notty
    $w = 132; 
  } else {
    if ($option{notty} == 0) {
      my $c = `stty size`; # get tty width and height
      if ($c) {
        chop($c);
        ($h, $w) = split(' ', $c);
        $h = 0;
      }
    }
  }
  #
  my ($len, $fmt, $item, $key, $value);
  #
  # figure out the width of the $name
  my $tLen = 1;
  foreach $item (@itemList) {
    ($len, $fmt, $key) = split(':', $keys{$item});
    if ($item ne 'name') {
      $fmt =~ s/\.[0-9]*//;
      $fmt =~ s/[a-z]/s/;
      $fmt = ' %'.$len.$fmt;
      $fmt .= $sep;
      my $str = sprintf($fmt, $item);
      $tLen += length($str)+1;
    }
  }
  # set width of $name 
  $w -= $tLen;
  if ($w < 15) {$w = 15; }
  $keys{name} =~ s/XX/$w/g;
  #
  # print header
  #
  my $hdr = '';
  if ($show{header} == 1) { 
    #
    &ShowHeader(\%total); 
    #
    foreach $item (@itemList) {
      ($len, $fmt, $key) = split(':', $keys{$item});
      my $alen = abs($len);
      $fmt =~ s/\.[0-9]*//;
      $fmt =~ s/[a-z]/s/;
      $fmt = ' %'.$len.$fmt;
      $fmt .= $sep;
      my $str = sprintf($fmt, $item);
      $hdr .= $str;
    }
    $hdr .= "\n";
  }
  #
  # loop on info
  #
  foreach $info (@info) {
    #
    %info = %{$info};
    #
    # state: r, hr, qw, hqw, Eqw, d, dr, t
    my $show;
    if ($info{j_state} eq 'r' || $info{j_state} eq 'hr') { # hr == r
      $show = $show{running};
    } elsif ($info{j_state} eq 'qw' || $info{j_state} eq 'hqw') { # hqw == qw
      $show = $show{queued};
    } else {
      $show = $show{others};
    }
    #
    if ($show == 1) {
      #
      if ($hdr ne '') {
        print $hdr;
        $hdr = '';
      }
      #
      my $showIt = 1;
      my $line = '';
      my $id = $info{j_JB_job_number};
      if ($info{j_tasks}) {
        $id .= '.'.$info{j_tasks};
      }
      #
      foreach $item (@itemList) {
        ($len, $fmt, $key) = split(':', $keys{$item});
        if ($show{raw} == 1) {
          $fmt = ' %'.$len.'.'.abs($len).'s';
        } else {
          $fmt = ' %'.$len.$fmt;
        }
        my $value = '';
        #  
        if ($key =~ /^\&/) {
          #
          if      ($key eq '&Queue') {
            if ($info{j_state} =~ /r$/ ) { 
              $value = $info{j_queue_name};
              $value =~ s/\@.*$//;
            } else {
              $value = $info{j_hard_req_queue};
            }
            #
          } elsif ($key eq '&Node') {
            $value = &GetNodeNumber($info{j_queue_name});
            #
          } elsif ($key eq '&Load') {
            if ($info{j_state} =~ /r$/ ) {
              $value = &Load($info{j_queue_name}, @infox);
            } # else { $fmt = ' %'.$len.'s'; }
            #
          } elsif ($key eq '&UseAvail') {
             if ($info{j_state} =~ /r$/) {
               $value = &UseAvail($info{j_queue_name}, @infox);
              } # else { $fmt = ' %'.$len.'s'; }
           #
          } elsif ($key eq '&SubStartTime') {
            if ($geType eq 'sge') {
              $value = &SubStartTime($id, @infox);
            } else {
              $value = &SubStartTime($id, @info);
            }
            $value = &CvtTime($value);
            #
          } elsif ($key eq '&Age') {
            if ($geType eq 'sge') {
              $value = &SubStartTime($id, @infox);
            } else {
              $value = &SubStartTime($id, @info);
            }
            #
            $value = &Age($value, @now);
            if ($show{raw} == 0) {
              $value = &FormatTime($value);
            }
          #
          } elsif ($key =~ /^\&Cpu/) {
            if ($info{j_state} =~ /r$/) {
              if (! $info{j_cpu_usage}) { $info{j_cpu_usage} = 0; }
              if ($key eq '&CpuT') {
                $value = $info{j_cpu_usage}/3600.;
                if ($show{raw} == 0) {
                  $value = &FormatTime($value);
                }
                #  
              } elsif ($key eq '&Cpu%') {
                if ($geType eq 'sge') {
                  $value = &SubStartTime($id, @infox);
                } else {
                  $value = &SubStartTime($id, @info);
                }
                my $age = &Age($value, @now);
                if ($age > 0) {
                  $value = $info{j_cpu_usage}/36.0/$age/$info{j_slots};
                } else {
                  $value = 0;
                }
                #
                if ($show{'osub'}) {
                  # use excess
                  # if ($option{'osubE'} > 0) {
                  my $excess = ($value-100.0)/100.0 * $age * $info{j_slots};
                  if ($excess <= $option{'osubE'} || $value <= $option{'osubT'} || $age < $option{'ageT'}) { $showIt = 0; }
                  #} else {
                  #  if ($value <= $option{'osubT'} || $age < $option{'ageT'}) { $showIt = 0; }
                  #}
                }
                #  
                if ($show{'ineff'}) {
                  if    ($info{j_full_job_name} eq 'QRLOGIN' ||
                         $value >= $option{'ineffT'} || $value == 0 || $age < $option{'ageT'}) { $showIt = 0; }  
                }
                #  
              } elsif ($key eq '&CpuR') {
                if ($geType eq 'sge') {
                  $value = &SubStartTime($id, @infox);
                } else {
                  $value = &SubStartTime($id, @info);
                }
                my $age = &Age($value, @now);
                if ($age > 0) {
                  $value = $info{j_cpu_usage}/3600.0/$age;
                } else {
                  $value = 0;
                }
                #  
              } else {
                $value = $key.'?';
              }
            } # else {$value = '';}
            #
          } elsif ($key =~ /^\&MemMean/ || ($key =~ /^\&MemUse/ && $info{j_state} =~ /r$/ ) ) {
            if ($info{j_mem_usage}) { 
              $value = 0;
              if ($info{j_cpu_usage}) { 
                if ($info{j_cpu_usage} > 0) { 
                  $value = $info{j_mem_usage}/$info{j_cpu_usage};
                }
              }
            }
          } elsif ($key =~ /^\&MemRes/ || ($key =~ /^\&MemUse/ && $info{j_state} !~ /r$/ ) ) {
            if ($info{'j_hard_request.mem_res'}) {
              $value = $info{'j_hard_request.mem_res'};
              if ($value =~ /[^0-9]$/) {
                my $unit = chop($value);
                if      ($unit eq 'k') {
                  $value /= 1024.0;
                  $value /= 1024.0;
                } elsif ($unit eq 'M') {
                  $value /= 1024.0;
                } elsif ($unit eq 'G') {
                  $value *= 1.0;
                } elsif ($unit eq 'T') {
                  $value *= 1024.0;
                } else {
                  print STDERR "mem_res unit=<$1>???\n";
                }
              } else { 
                $value /= 1024.0;
                $value /= 1024.0;
                $value /= 1024.0;
              }
              #
              # no VMem for queued jobs
              if ($key =~ /^\&MemResX/) {
                if ($info{j_state} =~ /r$/) {
                  my $vmem = &GetVMem($info{j_JB_job_number}, $info{j_tasks});
                  if ($vmem) {
                    $value /= $vmem;
                  }
                } else {
                  $value = '';
                }
                #
                if ($show{'ores'}) {
                  my $val;
                  if ($geType eq 'sge') {
                    $val = &SubStartTime($id, @infox);
                  } else {
                    $val = &SubStartTime($id, @info);
                  }
                  my $age = &Age($val, @now);
                  if ($value <= $option{'oresF'} || $value == 0 || $age < $option{'ageT'}) { $showIt = 0; }
                }
              }
              #
            } else {if ($show{'ores'}) {$showIt = 0} }
            #
          } elsif ($key =~ /^\&MemVMem/ && $info{j_state} =~ /r$/ ) {
            $value = &GetVMem($info{j_JB_job_number}, $info{j_tasks});
          } elsif ($key =~ /^\&MemMxVM/ && $info{j_state} =~ /r$/ ) {
            $value = &GetMaxVMem($info{j_JB_job_number}, $info{j_tasks});
          } elsif ($key =~ /^\&IOWait/) {
            $value = &GetIOWait($info{j_JB_job_number}, $info{j_tasks});
            $value = &FmtIOW($value);
          } elsif ($key =~ /^\&IOOPs/) {
            $value = &GetIOOPs($info{j_JB_job_number}, $info{j_tasks});
            $value = &FmtIOOps($value);
          } elsif ($key =~ /^\&IOUse/) {
            if ($info{j_state} =~ /r$/) {
              if ($info{j_io_usage}) { 
                $value = $info{j_io_usage}; ### /1000.0; UGE returns GB
                ### raw format use %e -> OK?
                $value = &FmtIOUse($value);
              }
              #
            } #else {$value = ''; $fmt = ' %'.$len.'s'; }
          }
          #
        } elsif ($info{'j_'.$key}) {
          $value = $info{'j_'.$key};
        } # else { $value = ''; }
        #
        # if $value was assigned an undef value -> set it to ''
        if (! ($value)) { $value = ''; }
        #
        # handle n/f
        if ($value eq '' or $value eq 'n/f') {
          # add a space if fmt ends w/ a %
          if ($fmt =~ /%$/) { $len++; }
          $fmt = ' %'.$len.'s';
        }
        $fmt .= $sep;
        $line .= sprintf($fmt, $value);
      }
      if ($showIt) {
        $line .= "\n";
        print $line; 
        ## die "here"
      }
    }
  }
  #
  if ($show{footer} == 1 ) { 
    &ShowFooter(\%total, \%lic); 
  }
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR "qstat+: ShowDetails() done in $elapsedTime sec\n";
  }
  #
}
#
# ---------------------------------------------------------------------------
#
sub ShowJstat {
  #
  my $subName = (caller(0))[3];
  $timeThen{$subName} = time();
  #
  # both xml parsing is iffy and what to print is not obvious, including diff tids, drop the -xml
  # @usage is tricky, and not tested on all diff cases
  #
  my ($key, $val);
  my %props = ();
  my @usage = ();
  #
  foreach my $l (@_) {
    #
    ($key, $val) = split(':', $l, 2);
    ## if ($key =~ /^usage/ && ! $option{tid}) {
    if ($key =~ /^usage/ ) {
      if ($option{tid}) {
        if ($key =~ /^usage *$option{tid}/ ) { @usage = (@usage, $key); }
        $val =~ s/,/\n                             /g;
      } else {
        @usage = (@usage, $key);
      }
      
      $val =~ s/=/ = /g;
    }
    #
    if ($props{$key}) {
      $props{$key} .= ', '.$val; 
    } else {
      $props{$key} = $val;
    }
  }
  #  
  my @keys = ('job_number', 'job_name', 'submission_time', 
              'cwd', 'script_file', 'job_args',
              'hard_queue_list', 'hard_resource_list',
              'parallel environment', 'state', @usage,
              'error reason',
      );
  #
  foreach $key (@keys) {
    $val = $props{$key};
    if ($val) {
      print " $key: $props{$key}";
    }
  }
  #
  if ($option{verbose}) {
    my $elapsedTime = time() - $timeThen{$subName};
    print STDERR  "qstat+: ShowJstat() hashing done in $elapsedTime sec\n";
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowNodeList { 
  #
  my @info = @_; # qstat -f
  my @jidx = split(',', $option{'jidList'});
  my $jidx;
  #
  print "   jobID  task jobname                             user             #pes/#nodes - list of nodes\n";
  #
  foreach $jidx (@jidx) {
    #
    my $jid = $jidx;
    my $tid = 0;
    if ($jidx =~ /\./) {
      ($jid, $tid) = split('\.', $jidx);
      if ($tid eq '') { $tid = 0; }
    }
    #
    my $info;
    my %info;
    #
    my $name;
    my $jobname;
    my $jobuser;
    my $host;
    my $queue;
    my $slots = 0;
    my %slots = ();
    my %loads = ();
    #
    foreach $info (@info) {
      %info = %{$info};
      #
      #
      # my xml parsing is not optimal: it should be a tree, not a list
      # for some jobid, the previous 'name' in the list is the appropriate one
      #
      if ($info{'q_name'}) {$name = $info{'q_name'}; }
      #
      if ($info{'j_JB_job_number'}) {
        #
        my  $infoTasks = 0;
        if ($info{'j_tasks'}) { $infoTasks = $info{'j_tasks'}; }
        #
        my $iOK = 0;
        if ($tid == 0) { 
          if ($info{j_JB_job_number} == $jid) { $iOK = 1; }
        } else {
          if ($info{j_JB_job_number} == $jid && $infoTasks == $tid) {  $iOK = 1; }
        }
        if ($iOK == 1) {
          ($queue, $host) = split('\@', $name);
          $host = &GetNodeNumber($host);
          $slots{$host} = $info{j_slots};
          $loads{$host} = $info{$q_load_avg};
          #
          $jobname = $info{j_JB_name};
          $jobuser = $info{j_JB_owner};
          $slots +=  $info{j_slots};
        }
      }
    }
    #
    my @host = sort (keys %slots);
    my $n = $#host+1;
    if ($n > 0) {
      my $str = sprintf('%5d/%d', $slots, $n);
      if ($tid == 0) {
        printf "%8d       %-35.35s %-15.15s %-12s -", $jid, $jobname, $jobuser, $str;
      } else {
        printf "%8d %5d %-35.35s %-15.15s %-12s -", $jid, $tid, $jobname, $jobuser, $str;
      }
      my $i = 0;
      $n = 10;
      foreach $host (@host) {
        if ($i > 0 && ($i % $n) == 0) {printf "\n%45s", '';}
        print " $slots{$host}\@$host";
        $i++;
      }
      print "\n";
    }
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowEmptySlots { 
  #
  my $showDetails = shift(@_); # 0,1
  my @info = @_; # qstat -f
  my $info;
  my %info;
  #
  my $host;
  my $name;
  my $queue;
  my $empty;  
  my $free;
  #
  my (%hLoad, %hSlot, %hUsed, %qList, %qUsed, %queues, %dSlot);
  #
  foreach $info (@info) {
    %info = %{$info};
    if ($info{q_name})  {
      #
      $name = $info{q_name};
      ($queue, $host) = split('@', $name, 2);
      # ignore all.q
      if ($queue !~ /$ignQueue/) {
        $host = &GetNodeNumber($host);
        #
        if (defined $info{$q_load_avg}) {
          # if the host/queue is avail
          my $enabled = 1;
          if ($info{q_state}) {
            if ($info{q_state} =~ /[daE]/) { $enabled = 0; }
          }
          #
          if ($enabled == 1) {
            $hLoad{$host}   = $info{$q_load_avg};
            $hSlot{$host}   = $info{q_slots_total};
            $hUsed{$host}  += $info{q_slots_used};
            $qList{$host}  .= ' '.$queue;
            $qUsed{$queue} += $info{q_slots_used};
            $queues{$queue}++;
          } else {
            $dSlot{$host} = $info{q_slots_total};
          }
        }  else { $dSlot{$host} = $info{q_slots_total}; }
      }
    }
  }
  #
  my %total = ();
  $total{empty} = 0;
  $total{load}  = 0;
  $total{used}  = 0;
  $total{slots} = 0;
  $total{nodes} = 0;
  my %nEmpty    = ();
  my %nFree     = ();
  #
  foreach $host (sort(keys %hLoad)) {
    $empty = $hSlot{$host}-$hUsed{$host};
    $free  = $hSlot{$host}-$hLoad{$host};
    $total{empty} += $empty;
    $total{used}  += $hUsed{$host};
    $total{slots} += $hSlot{$host};
    $total{load}  += $hLoad{$host};
    # what slots are avail?
    if ($empty > 1) {
      $nEmpty{$host} = $empty;
      $nFree{$host}  = $free;
    }
  }
  #
  $total{slots_disabled} = 0;
  foreach $host (sort(keys %dSlot)) {
    $total{slots_disabled} += $dSlot{$host};
  }
  my $s;
  if ($total{empty} > 1) { $s = 's';} else { $s = '';}
  printf "Cluster load=%d, running=%d/%d, %d empty slot$s (%d disabled)\n",
    $total{load}, $total{used}, $total{slots}, $total{empty}, $total{slots_disabled};
  #
  foreach $queue (sort(keys %queues)) {
    if ($qUsed{$queue} > 0) {
      printf " %10d slot%s used in %s\n", 
      $qUsed{$queue}, 
      ($qUsed{$queue} > 1 ? 's' : ' '), 
      $queue;
    }
  }
  print "\n";
  #
  my (%qFree, %qEmpty);
  #
  if ($showDetails == 1) {
    print "      slot(s) CPU   no of slots      queues\n";
    print " host  empty  free (avail used load) avail\n";
  }
  foreach $host (sort(keys %nEmpty)) {
    my %qL = ();
    foreach $queue (split(' ', $qList{$host})) {
   #  $queue =~ s/^./?/;
   #  $queue =~ s/.rq$//;
   #  $queue =~ s/.q$//;
      $qL{$queue}++;
    }
    #
    my $qList = join(' ', sort(keys %qL));
    #
    if ($showDetails == 1) {
      printf "  %-5s  %3d %5.1f (%3d  %3d  %5.1f) %s\n", 
      $host, $nEmpty{$host}, 
      $nFree{$host}, $hSlot{$host}, $hUsed{$host}, $hLoad{$host}, $qList;
    }
    $qEmpty{$qList} += $nEmpty{$host};
    $qFree{$qList}  += $nFree{$host};
  }
  if ($showDetails == 1) {
    print "\n";
  }
  foreach $queue (sort(keys %qEmpty)) {
    printf "%5d/%5.1f slots/CPUs empty in %s\n", $qEmpty{$queue}, $qFree{$queue}, $queue;
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowClusterStats { 
  #
  my @info = @_; # qstat -f
  my $info;
  my %info;
  #
  my $host;
  my $name;
  my $queue;
  #
  my (%host, %down, %qLoad, %qSlot, %qResv, %qUsed, %qDown);
  #
  foreach $info (@info) {
    %info = %{$info};
    #
    if ($info{q_name})  {
      #
      $name = $info{q_name};
      ($queue, $host) = split('@', $name, 2);
      #
      if (defined $info{$q_load_avg}) {
        $host{$queue}++;
        $qLoad{$queue} += $info{$q_load_avg};
        $qSlot{$queue} += $info{q_slots_total};
        $qResv{$queue} += $info{q_slots_resv};
        $qUsed{$queue} += $info{q_slots_used};
      } else {
        $down{$queue}++;
        $qDown{$queue} += $info{q_slots_total};
      } 
    }
  }
  #
  printf "   ---- queue ----  ----- #nodes ---- - ---------- #slots ----------- - ------------\n";
  printf "   name       load  total avail  down - total used  resvd  down avail - %%full  %%eff\n";
  #
  my $avail;
  my $aSlot;
  my $pc;
  #
  my $total    = 0;
  my $lastLoad = 0;
  foreach $queue (@queueSet) {
    #
    if ($queue eq '') {
      my $eff = 0.0;
      if ($total > 0) {
        $eff = 100.0 * $lastLoad/$total;
      }
      printf " %5.1f\n", $eff;
      $total = 0;
    } elsif ($qSlot{$queue}) {
      print "\n";
      if ($down{$queue}) {
        $avail = $host{$queue}  - $down{$queue};
      } else {
        $down{$queue} = 0;
        $avail = $host{$queue};
      }
      #
      $aSlot = $qSlot{$queue} -  $qResv{$queue} - $qUsed{$queue};
      if ($qDown{$queue}) {$aSlot -= $qDown{$queue};} else {$qDown{$queue} = 0;}
      # %used, not %load
      $pc =  100.0 * $qUsed{$queue}/$qSlot{$queue};
      printf "   %-8s %6.1f  %5d %5d %5d - %5d %5d %5d %5d %5d - %5.1f", 
        $queue, $qLoad{$queue},
        $host{$queue}, $avail, $down{$queue},
        $qSlot{$queue}, $qUsed{$queue}, $qResv{$queue}, $qDown{$queue}, $aSlot, $pc;
      $total   += $qUsed{$queue};
      $lastLoad = $qLoad{$queue};
    } else {
      # 
      printf "   %-8s   -NA-\n", $queue;
    }
  }
  print "\n";
}
#
# ---------------------------------------------------------------------------
#
sub ShowDown { 
  #
  my @info = @_; # qstat -f
  my $info;
  my %info;
  #
  my $host;
  my $name;
  my $queue;
  #
  my %down;
  #
  foreach $info (@info) {
    %info = %{$info};
    if ($info{q_name})  {
      #
      if (! defined $info{$q_load_avg}) {
        #
        $name = $info{q_name};
        ($queue, $host) = split('@', $name, 2);
        $host = &GetNodeNumber($host);
        $down{$host}++;
      } 
    }
  }
  my @host = sort keys(%down);
  my $n = $#host+1;
  my $s = '';
  my $p = '.';
  if ($n > 1) { $s = 's'; }
  if ($n > 0) { $p = ':'; }
  print "$n node$s down$p";
  foreach $host (@host) {
    print " $host";
  }
  print "\n";
}
#
# ---------------------------------------------------------------------------
#
sub ShowHiLoad { 
  #
  my @info = @_; # qstat -f
  my $info;
  my %info;
  #
  my $node;
  my $fnode;
  my $name;
  my $queue;
  #
  my @mark = ('', '');
  #
  my $n  = 0;
  my $ni = 0;
  my (%load, %total, %used);
  #
  foreach $info (@info) {
    %info = %{$info};
    if ($info{q_name})  {
      #
      if (defined $info{$q_load_avg}) {
        $name = $info{q_name};
        ($queue, $node) = split('@', $name, 2);
        if ( $node =~ /^$nodePrfx/ ) {
          $node = &GetNodeNumber($node);
          #
          $used{$node}  += $info{q_slots_used};
          if ($info{q_slots_total}) {
            $total{$node}  = $info{q_slots_total};
          }
        }
      }
    }
  }
  #
  foreach $info (@info) {
    %info = %{$info};
    if ($info{q_name})  {
      #
      if (defined $info{$q_load_avg}) {
        $name = $info{q_name};
        ($queue, $node) = split('@', $name, 2);
        if ( $node =~ /^$nodePrfx/ ) {
          $node = &GetNodeNumber($node);
          #
          my $xLoad = $used{$node} + $option{'offset'};
          #
          if ($load{$node}) {
            # no need to check a node twice
          } else {
            if ($info{$q_load_avg} > $xLoad) {
              #
              if ($option{'check-load'}) {
                # hydra and login hardwired
                # -------------------------
                if ($node =~ /^hydra/ || $node =~ /^login/) {
                  $fnode = "$node";
                } else {
                  $fnode = "$nodePrfx$node";
                }
                $info = &Uptime($fnode);
                # catch if fails.
                if ($? == 0) {
                  my @loads = split(',', $info);
                  $load{$node} = $loads[0];
                  $ni++;
                  if ( $load{$node} > $xLoad ) {
                    $n++;
                  } else {
                    $load{$node} = -$load{$node};
                  }
                }
              } else {
                #
                $load{$node} = $info{$q_load_avg};
                $n++;
                $ni++;
              }
            }
          }
        } 
      }
    }
  }
  #
  if ($show{header} == 1) {
    printf " %d node%s", $n, ( $n > 1 ? 's' : '');
    if ($option{'check-load'}) {
      print " have a high load (offset=$option{'offset'}, $ni checked)\n\n";
    } else {
      print " have a high load (offset=$option{'offset'})\n\n";
    }
    print "                #slots        excess\n";
    print "    node  #CPUs   used   load   load\n";
    print " -----------------------------------\n";
    #                                                                                                                              
    # use display to decide on the coloring
    my $d = $ENV{'DISPLAY'};
    if ($d) {
      if ($d =~ /^xterm/) {
        @mark = ('^[[0;31m', '^[[0m');
      }
    }
  }
  #
  my $tot = 0;
  foreach $node (sort bynode keys(%load)) {
    if ($load{$node} > 0) {
      my $diff = $load{$node}-$used{$node};
      $tot += $diff;
      my @m = ('','');
      if ($load{$node} > $total{$node}) { @m = @mark; }
      printf "%s%8s %6d %6d %6.1f %6.1f%s\n",
      $m[0], $node, $total{$node}, $used{$node}, $load{$node}, $diff, $m[1];
    }
  }
  
  if ($show{header} == 1) {
    printf "\n         Total excess load = %5.1f\n", $tot;
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowUserList {
  #
  my @refs = &CompileStats(@_);
  #
  my %cntR  = %{$refs[0]};
  my %cntRJ = %{$refs[1]};
  my %cntQ  = %{$refs[2]};
  my %cntQT = %{$refs[3]};
  my %cntQJ = %{$refs[4]};
  my %cntX  = %{$refs[5]};
  my %total = %{$refs[6]};
  my %lic   = %{$refs[7]};
  my %cntXS = %{$refs[8]};
# my %qDis  = %{$refs[9]};
# my %qAtt  = %{$refs[10]};
# my %qErr  = %{$refs[11]};
  #
  my @users;
  my ($n, $user);
  my $s;
  #
  if ($show{header} == 1) { &ShowHeader(\%total); }
  #
  @users = sort keys %cntR;
  $n = $#users+1;
  if ($n > 0) {
    # count jobs or slots
    $s = 'PEs/jobs';
    if   ($option{cntPE} ==  1) {$s = 'PEs' } 
    elsif($option{cntPE} == -1) {$s = 'jobs'} # count jobs or slots
  
    if ($option{user} eq "'*'"  || $option{'user'} =~ /,/) {
      printf "  %d user%s with", $n, ($n > 1 ? 's' : '');
    } 
    printf " running jobs (%s):\n", $s;
    foreach $user (@users) {
      if      (($option{cntPE} % 2) ==  0) {
        $s = &XVals($cntR{$user}, $cntRJ{$user});
        printf "  %11s for %s\n", $s, $user;
      } elsif ($option{cntPE} ==  1) { 
        printf "  %11d for %s\n", $cntR{$user}, $user;
      } elsif ($option{cntPE} == -1) { 
        printf "  %11d for %s\n", $cntRJ{$user}, $user;
      }
    }
  }
  #
  @users = sort keys %cntQJ;
  $n = $#users+1;
  if ($n > 0) {
    # count jobs or slots
    $s = 'jobs/tasks';
    if   ($option{cntPE} ==  1) {$s = 'PEs' } 
    elsif($option{cntPE} == -1) {$s = 'jobs'}
    elsif($option{cntPE} ==  2) {$s = 'jobs/PEs'}
    elsif($option{cntPE} ==  4) {$s = 'jobs/tasks/PEs'}

    if ($option{user} eq "'*'"  || $option{'user'} =~ /,/) {
      printf "  %d user%s with %s", $n, ($n>1?'s':''), $s;
    } 
    printf " queued jobs (%s):\n", $s;
    foreach $user (@users) {
      if       ($option{cntPE} == 0) { 
        $s = &XVals($cntQJ{$user}, $cntQT{$user});
      } elsif ($option{cntPE} ==  1) { 
        $s = sprintf("%d", $cntQ{$user});
      } elsif ($option{cntPE} == -1) { 
        $s = sprintf("%d", $cntQJ{$user});
      } elsif ($option{cntPE} ==  2) { 
        $s = &XVals($cntQJ{$user}, $cntQ{$user});
      } elsif ($option{cntPE} ==  4) { 
        if ($cntQ{$user} == $cntQJ{$user}) {
          $s = sprintf("%d", $cntQ{$user});
        } else {
          $s = sprintf("%d/%d/%d", $cntQJ{$user}, $cntQT{$user}, $cntQ{$user});
        }
      }
      printf "  %11s for %s\n", $s, $user;
    }
  }
  #
  @users = sort keys %cntX;
  $n = $#users+1;
  if ($n > 0) {
    if ($option{user} eq "'*'"  || $option{'user'} =~ /,/) {
      printf "  %d user%s with", $n, ($n>1?'s':'');
    } 
    printf " extra jobs:";
    foreach my $state (sort keys(%cntXS)) { print " $state($cntXS{$state})"; }
    printf "\n";
    foreach $user (@users) {
      printf "  %11d for %s\n", $cntX{$user}, $user;
    }
  }
  if ($show{footer} == 1) { 
    &ShowFooter(\%total, \%lic);     
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowSSDUsage {
  my @lines = @{$_[0]};
  #
  shift(@lines);
  shift(@lines);
  @lines = (@lines, '---');
  #
  print "  Node   -------------------------- /ssd -------------------------------\n";
  print "  Name     Size   Used  Avail    Use% |   Resd  Avail  Resd% | Resd/Used\n";
  my $k = 0;
  my ($line, $node, $qname, $qtyp, $rut, $npLoad, $arch, $states, $key, $rat, $load);
  my (%ssd, %tot, %pc);
  foreach $line (@lines) {
    chomp($line);
    if ($k == 0) {
      ($qname, $qtyp, $rut, $npLoad, $arch, $states) = split(' ', $line);
      $node = &GetNodeNumber($qname);
      $k++;
    } elsif ( $line =~ /ssd_total=/) {
      ($key, $ssd{total}) = split('=', $line);
      $ssd{total} = &CvtSSD($ssd{total});
    } elsif ( $line =~ /ssd_free=/) {
      ($key, $ssd{free}) = split('=', $line);
      $ssd{free} = &CvtSSD($ssd{free});
    } elsif ( $line =~ /ssd_res=/) {
      ($key, $ssd{unresd}) = split('=', $line);
      $ssd{unresd} = &CvtSSD($ssd{unresd});
    } elsif ($line =~ /^\-\-\-/) {
      $k = 0;
      my ($r,$u,$t)= split('/',$rut);
      if ($npLoad eq '-NA-') {
        $load = '-NA-';
      } else {
        $load = $t * $npLoad;
      }
      $ssd{used} = $ssd{total} - $ssd{free};
      $ssd{resd} = $ssd{total} - $ssd{unresd};
      if ($ssd{resd} < 0) { $ssd{resd}=0; }
      if ($ssd{total} > 0) {
        $pc{used} = 100.0*$ssd{used}/$ssd{total};
        $pc{resd} = 100.0*$ssd{resd}/$ssd{total};
      } else {
        $pc{used} = 0.0;
        $pc{resd} = 0.0;
      }
      if ($ssd{used} > 0) { $rat = $ssd{resd}/$ssd{used}; } else { $rat = 0.; }
      #
      printf "%6s   %5s %5s %5s %6.1f%% | %5s %5s %5.1f%% | %6.2f\n",
        $node,
      &FmtSSD($ssd{total}), &FmtSSD($ssd{used}), &FmtSSD($ssd{free}), $pc{used}, 
      &FmtSSD($ssd{resd}),  &FmtSSD($ssd{unresd}),                 $pc{resd}, $rat;
      #
      $tot{total}  += $ssd{total};
      $tot{used}   += $ssd{used};
      $tot{free}   += $ssd{free};
      $tot{unresd} += $ssd{unresd};
      $tot{resd}   += $ssd{resd};
    } else {
    }
  }
  #
  if ($tot{resd} < 0) { $tot{resd}=0; }
  if ($tot{total} > 0) {
    $pc{used} = 100.0*$tot{used}/$tot{total};
    $pc{resd} = 100.0*$tot{resd}/$tot{total};
  } else {
    $pc{used} = 0.;
    $pc{resd} = 0.;
  }
  if ($tot{used} > 0) { $rat = $tot{resd}/$tot{used}; } else { $rat = 0.; }
  print "         ---------------------------------------------------------------\n";
  printf "%6s   %5s %5s %5s %6.1f%% | %5s %5s %5.1f%% | %6.2f\n",
  'Total',
  &FmtSSD($tot{total}), &FmtSSD($tot{used}), &FmtSSD($tot{free}), $pc{used}, 
  &FmtSSD($tot{resd}),  &FmtSSD($tot{unresd}), $pc{resd}, $rat;
}
#
# ---------------------------------------------------------------------------
#
sub ShowHeader {
  my %total = %{$_[0]};
  printf "Total running (PE%s/job%s) = %d/%d, %d queued (job%s)",
  ($total{runPEs}>0?'s':''), ($total{runJobs}>0?'s':''),
  $total{runPEs}, $total{runJobs}, 
  $total{queued},
  ( $total{queued}>0?'s':'');
  if ($total{extra} > 0) {
    printf ", %d extra", $total{extra};
  }
  if ($show{ores}) {
    print ", showing only jobs w/ over-res mem (resMem/maxVMem > $option{oresF} & age > $option{ageT}h)";
  }
  if ($show{osub}) {
    print ", showing only oversubscribed jobs (cpu% > $option{osubT}% & age > $option{ageT}h)";
    if ($option{osubE} > 0) {
      print " and excess > $option{osubE} hr x slots";
    }
  }
  if ($show{ineff}) {
    print ", showing only inefficient jobs (cpu% < $option{ineffT}% & age > $option{ageT}h)";
  }
  if ($option{queue}) {
    print " for jobs in queue '$option{queue}'";
  }
  if ($option{user} eq "'*'") {
    print " for all users.\n";
  } elsif ($option{user} eq '$USER') {
    print " for user '$ENV{USER}'.\n";
  } else {
    print " for user '$option{user}'.\n";
  }
}
#
# ---------------------------------------------------------------------------
#
sub ShowFooter {
  my %total = %{$_[0]};
  my %lic   = %{$_[1]};

  my $pc  = 0.0;
  my $eff = 0.0;
  if ($total{slots}     > 0) {$pc  = 100.0 * $total{slotsUsed}/$total{slots}; }
  if ($total{slotsUsed} > 0) {$eff = 100.0 * $total{load}/$total{slotsUsed}; }
  #
  printf "Load=%.1f, %d/%d slots avail/disabled (%d nodes, %d down)",
    $total{load}, $total{slots}, $total{slots_disabled},
    $total{nodes}, $total{down};
  #
  my $none = ' none used.';
  if ($show{license}) {
    print ', licenses:';
    foreach my $key (sort(keys(%lic))) {
      print " $lic{$key} $key used";
      $none = '.';
    }
  }
  print "$none\n";
  #
  my $s = 'y';
  if ($total{err} > 1 || 
      $total{dis} > 1 || 
      $total{att} > 1 ) { $s = 'ies'; }
  if ($total{err} == 0) {
    printf " %d/%d queue entr$s disabled/need attention", 
      $total{dis}, $total{att};
  } else {
    printf " %d/%d/%d queue entr$s disabled/need attention/in Error state", 
      $total{dis}, $total{att}, $total{err};
  }

  printf ", cluster is %.1f%% used at %.1f%% eff.\n",
  $pc, $eff;
}
#
# ---------------------------------------------------------------------------
#
sub ShowSummary {
  #
  my @refs = &CompileStats(@_);
  #
  my %cntR  = %{$refs[0]};
  my %cntRJ = %{$refs[1]};
  my %cntQ  = %{$refs[2]};
  my %cntQT = %{$refs[3]};
  my %cntQJ = %{$refs[4]};
  my %cntX  = %{$refs[5]};
  my %total = %{$refs[6]};
  my %lic   = %{$refs[7]};
  my %cntXS = %{$refs[8]};
  my %qDis  = %{$refs[9]};
  my %qAtt  = %{$refs[10]};
  my %qErr  = %{$refs[11]};
  my %down  = %{$refs[12]};
  #
  my @users;
  my ($n, $user);
  #
  my $sep = ';';
  my $smc = ';';
  my $snl = "\n";
  if ($show{sfmt} == 1) { 
    $sep = "\n";
    $smc = '; ';
  } elsif ($show{sfmt} == 2) { 
    $sep = ' |';
    $smc = ';';
    $snl = ' | ';
  }
  #
  my $logName;
  my $logLoads = '';
  foreach $logName (@logNames) {
    if ($logLoads ne '') {$logLoads .= $smc; }
    $logLoads .= &Uptime($logName);
  }
  #
  my $loads = $logLoads;
  if ($#nsdNames > -1) {
    my $nsdLoads = '';
    foreach $logName (@nsdNames) {
      if ($nsdLoads ne '') {$nsdLoads .= $smc; }
      $nsdLoads .= &Uptime($logName);
    }       
    #
    $loads .= ' nsd='.$nsdLoads;
  }
  my $now    = scalar localtime(time());
  #
  printf "%s running=%d/%d queued=%d$sep loads=%s$snl",
    $now,
    $total{runPEs}, $total{runJobs}, 
    $total{queued}, $loads;
  #
  @users = sort keys %cntR;
  if ($show{sfmt} == 1) {
    $n = $#users + 1;
    my $s = ''; if ($n > 1) { $s ='s'; }
    printf " %d user$s with running job(s)", $n;
  } else {
    if ($show{sfmt} == 2) {
      $n = $#users + 1;
      printf " %d", $n;
    }
    print " r:";
    foreach $user (@users) {
      printf " %s=%s", $user, &XVals($cntR{$user}, $cntRJ{$user});
    }
  }
  print "$snl";
  #
  @users = sort keys(%cntQ);
  if ($show{sfmt} == 1) {
    $n = $#users + 1;
    my $s = ''; if ($n > 1) { $s ='s'; }
    printf " %d user$s with queued job(s)", $n;
  } else {
    if ($show{sfmt} == 2) {
      $n = $#users + 1;
      printf " %d", $n;
    }
    print " q:";
    foreach $user (@users) {
      my $s;
      if ($cntQ{$user} == $cntQJ{$user}) {
        $s = sprintf "%d", $cntQ{$user};
      } else {
        $s = sprintf "%d/%d/%d", $cntQJ{$user}, $cntQT{$user}, $cntQ{$user};
      }
      if ($cntX{$user}) {
        printf " %s=%s+%d", $user, $s, $cntX{$user};
      } else {
        printf " %s=%s", $user, $s;
      }
    }
  }
  print "$snl";
  #
  printf "Cluster load=%.1f CPUs=%d nodes=%d down=%d",
    $total{load}, $total{slots}, 
    $total{nodes}, $total{down};
    #
  if ($show{sfmt} == 1) {
    print "$sep queues=".join("\n     ",split(' ',$total{queues}));
  } elsif ($show{sfmt} == 2) {
    print "$sep queues=".join(" ",split(' ',$total{queues}));
  } else {
    print "$sep queues=$total{queues}";
  }
  #
  if ($total{down} > 0) { 
    print "$sep down=",join(',',sort(keys(%down))); 
  } else {
    print "$sep down=none";
  }
  print "$sep disabled_slots=$total{slots_disabled}";
  print "$sep racks=$total{racks}";
  #
  my @lic = ();
  my $name;
  foreach $name (sort(keys(%lic))) {
    @lic = (@lic, "$name:$lic{$name}");
  }
  print "$sep licenses=",join(',', @lic);
  #
  print "$sep qstate";
  ShowQState('=d', \%qDis);
  ShowQState(' a', \%qAtt);
  ShowQState(' e', \%qErr);
  #
  print "\n";
  #
}
#
# ---------------------------------------------------------------------------
#
sub ShowQState {
  my $s = shift();
  my $a = shift();
  my %v = %{$a};
  # ignore 'all.q'
  my $n = 0;
  foreach my $q (keys(%v)) { 
    if ($q !~ /$ignQueue/) { $n += $v{$q}; }
  }
  print "$s:$n";
  foreach my $q (keys(%v)) { 
    if ($q !~ /$ignQueue/) { print ":$q=$v{$q}"; }
  }
}
#
# ---------------------------------------------------------------------------
#
sub FmtIOW {
  my $value = $_[0];
  #
  if ($value eq '') { return '       '; }
  if ($show{raw} == 1) {
    $value = sprintf("%.2e", $value);
  } else {
    if ($value > 1000.0) {
      $value /= 1000.0;
      $value = sprintf("%5.2fks", $value);
    } else {
      $value = sprintf("%5.2fs ", $value);
    }
  }
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub FmtIOOps {
  my $value = $_[0];
  #
  if ($value eq '') { return '      '; }
  if ($show{raw} == 1) {
    $value = sprintf("%.2e", $value);
  } else {
    if ($value > 1000000000.0) {
      $value /= 1000000000.0;
      $value = sprintf("%5.2fG", $value);
    } elsif ($value > 100000.0) {
      $value /= 1000000.0;
      $value = sprintf("%5.2fM", $value);
    } elsif ($value > 1000.0) {
      $value /= 1000.0;
      $value = sprintf("%5.2fk", $value);
    } else {
      $value = sprintf("%6.2f", $value);
    }
  }
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub FmtIOUse {
  my $value = $_[0];
  #
  if ($show{raw} == 1) {
    $value = sprintf("%.2e", $value);
  } else {
    if ($value > 100000.0) {
      $value /= 1000.0;
      $value = sprintf("%7.1fT", $value);
    } elsif ($value < 1.0) {
      $value *= 1000.0;
      $value = sprintf("%7.1fM", $value);
    } else {
      $value = sprintf("%7.1fG", $value);
    }
  }
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub CvtSSD {
  my $value = $_[0];
  if ($value eq 'N/A') {
    return 0;
  }
  $value =~ s/(.)$//;
  my   $unit  = $1;
  if      ($unit eq 'G') {
  } elsif ($unit eq 'T') {
    $value *= 1024;
  } elsif ($unit eq 'M') {
    $value /= 1024;
  } elsif ($unit eq 'K') {
    $value /= 1024*1024;
  } elsif ($unit =~ /[0-9]/) {
    $value = $value.$unit;
    $value /= 1024*1024*1024;
  } else {
    die ">Cvt($_[0])>> $value $unit";
  }
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub FmtSSD {
  my $value = $_[0];
  my $str;
  if ($value >= 102400) {
    $str = sprintf("%5.1fT", $value/1024.0);
  } elsif ($value >= 1000) {
    $str = sprintf("%5.2fT", $value/1024.0);
  } else {
    $str = sprintf("%5.1fG", $value);
  }
  return $str;
}
#
# ---------------------------------------------------------------------------
#
sub Load {
  #
  my $id = shift(@_);
  my @infox = @_;
  my $kex = '@load_avg';
  if ($geType eq 'uge') {
    $kex = '@np_load_avg';
  }
  my $value = &GetValQList($kex, $id, @infox);

  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub UseAvail {
  #
  my $id = shift(@_);
  my @infox = @_;
  my $kex = '@slots_used';
  my $value = &GetValQList($kex, $id, @infox);
  $kex = '@slots_total';
  $value .= '/'.&GetValQList($kex, $id, @infox);
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub SubStartTime {
  #
  my $id = shift(@_);
  my @infox = @_;
  my $kex = '@JAT_start_time|JB_submission_time';
  my $value = &GetValJList($kex, $id, @infox);
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub CvtTime {
  # n/f -> ?
  my $v = '?';
  # yyyy-mm-ddThh:mm:ss -> "mm/dd hh:mm"
  my @w = split('[\-:T]', $_[0]);
  if ($#w >= 4) { 
    $v = $w[1].'/'.$w[2].' '.$w[3].':'.$w[4];
  } else {
    $v = $_[0];
  }
  return $v;
}
#
# ---------------------------------------------------------------------------
#
sub FormatTime {
  # dt = +D:HH or HH:MM
  my $dt = $_[0];
  if ($dt eq 'NA') { return 0; }
  my $dd = int($dt/24); # days
  my $hh = int($dt - 24*$dd); # hours
  my $mm = int(($dt - 24*$dd - $hh)*60 + 0.5); # mins
  if ($dd > 0) {
    my $mx = int( $hh+$mm/60.);
    $dt = sprintf("+%d:%2.2d", $dd, $mx);
  } else {
    $dt = sprintf("%2.2d:%2.2d", $hh, $mm);
  }
  #
  return $dt;
}
#
# ---------------------------------------------------------------------------
#
sub Age {
  #
  my @mm = (0,31,28,31,30,31,30,31,31,30,31,30,31);
  my $str = shift(@_);
  my $dt;
  if ($str eq 'n/f') {
    $dt = 0.0;
  } else {
    my @d0 = split('[T\-:]', $str);
    my @d1 = @_;
    #
    my ($mm, $dd, $dx0, $dx1, $t0, $t1, $y0, $y1);
    $dx0 = $d0[2]; for ($mm=0; $mm < $d0[1]; $mm++) { $dx0 += $mm[$mm]; }
    $dx1 = $d1[2]; for ($mm=0; $mm < $d1[1]; $mm++) { $dx1 += $mm[$mm]; }
    #
    $t0 = $d0[3]+$d0[4]/60.+$d1[5]/3600.;
    $t1 = $d1[3]+$d1[4]/60.+$d1[5]/3600.;
    $dt = $t1-$t0 + ($dx1-$dx0)*24.; # in hours
    #
    $y0 = $d0[0];
    $y1 = $d1[0];
    $dt += ($y1-$y0)*365.0*24.0;
    #
  }
  return $dt;
}
#
# ---------------------------------------------------------------------------
#
sub Total {
  my $n = 0;
  my %v = @_;
  # ingore all.q
  foreach my $q (keys(%v)) {
    if ($q !~ /$ignQueue/) { $n += $v{$q}; }
  }
  return $n;
}
#
# ---------------------------------------------------------------------------
#
sub XVals { # (a, b)
  my $a = $_[0];
  my $b = $_[1];
  my $sx = '';
  if ($a == $b) {
    $sx = sprintf("%d", $a);
  } else {
    $sx = sprintf("%d/%d", $a, $b);
  }
  return $sx;
}
#
# ---------------------------------------------------------------------------
#
sub GetValJList {
  #
  my $keys = shift(@_);
  my $idx  = shift(@_);
  #
  my ($id, $ref, $key);
  my %info;
  my %hash;
  #
  $keys =~ s/^.//;
  if (! $hashJListTable{$keys}) {
    #
    my $subName = (caller(0))[3];
    $timeThen{$subName} = time();
    #
    foreach $ref (@_) {
      %info = %{$ref};
      #
      if ($info{j_JB_job_number}) {
        $id = $info{j_JB_job_number};
        if ($info{j_tasks}) {
          $id .= '.'.$info{j_tasks};
        }
        #
        foreach $key (split('\|', $keys)) {
          my $jKey = 'j_'.$key;
          if ($info{$jKey}) {
            my $idKey= $id.'|'.$key;
            $hash{$idKey} = $info{$jKey};
          }
        }
      }
    }
    $hashJListTable{$keys} = \%hash;
    #
    if ($option{verbose}) {
      my $elapsedTime = time() - $timeThen{$subName};
      #
    }
    #
  } else {
    %hash = %{$hashJListTable{$keys}};
  }
  #
  foreach $key (split('\|', $keys)) {
    my $idKey = $idx.'|'.$key;
    my $value = $hash{$idKey};
    if ($value) {
      return $value;
    }
  }
  #
  return 'n/f';
}
#
# ---------------------------------------------------------------------------
#
sub GetValQList {
  #
  my $keys = shift(@_);
  my $idx  = shift(@_);
  #
  my ($id, $ref, $key);
  my %info;
  my %hash;
  #
  $keys =~ s/^.//;
  if (! $hashQListTable{$keys}) {
    #
    my $subName = (caller(0))[3];
    $timeThen{$subName} = time();
    #
    foreach $ref (@_) {
      %info = %{$ref};
      if ($info{q_name}) {
        $id = $info{q_name};
        foreach $key (split('\|', $keys)) {
          my $qKey = 'j_'.$key;
          if (defined $info{$qKey}) { 
            my $idKey= $id.'|'.$key;
            $hash{$idKey} = $info{$qKey};
          }
        }
      }
    }
    $hashQListTable{$keys} = \%hash;
    #
    if ($option{verbose}) {
      my $elapsedTime = time() - $timeThen{$subName};
      print STDERR  "qstat+: GetValQList() hashing done in $elapsedTime sec\n";
    }
    #
  } else {
    %hash = %{$hashQListTable{$keys}};
  }
  #
  foreach $key (split('\|', $keys)) {
    my $idKey = $idx.'|'.$key;
    my $value = $hash{$idKey};
    if ($value) {
      return $value;
    }
  }
  return 'n/f';
}
#
# ---------------------------------------------------------------------------
#
sub GetNodeNumber {
  my $v = shift(@_);
  my $value = $v;
  my @w;
  if ($value =~ /\@/) {
    @w = split('\@', $value, 2); $value = $w[1];
  }
  if ($value =~ /\-/) {
    @w = split('\-', $value, 2); $value = $w[1];
  }
  if ($value =~ /\./) {
    @w = split('\.', $value, 2); $value = $w[0];
  }
  #
  return $value;
}
#
# ---------------------------------------------------------------------------
#
sub GetJobInfo {
  my $mem  = shift();
  my $id   = shift();
  my $tid  = shift();
  if (! $tid) { $tid = 1; }
  #
  my $cmd = $qstat.' -j '.$id;
  #
  if ($option{fake}) {
    if ($option{verbose}) {
      print STDERR "qstat+: GetJobInfo(): should be executing <$cmd>\n";
    }
    return '';
  }
  # 
  if ($option{verbose}) {
    print STDERR "qstat+: GetJobInfo(): executing <$cmd>\n";
  }
  #
  my @lines;
  if ($saveCmd eq $cmd) {
    @lines = @{$saveLines};
  } else {
    @lines = `$cmd`;
    if ($? != 0) {
      return '';
      # die "qstat+: GetJobInfo(): command failed <$!>\n";
    }
    # save to avoid running it 2x
    $saveCmd  = $cmd;
    $saveLines = \@lines;
  }
  #
  my @usage = grep /^usage *$tid:/, @lines;
  #
  if ($#usage == 0) {
    my $usage = $usage[0];
    $usage =~ s/.* $mem=([0-9\.]*)(..)//;
    my $value = $1;
    my $unit  = $2;
    $unit =~ s/ //;
    $unit =~ s/,//;
    if      ($unit eq 'G') {
      return $value;
    } elsif ($unit eq 'M') {
      return $value/1024.0;
    } elsif ($unit eq 's') {
      return $value;
    } else { 
      #
      if ($value =~ /^[0-9\.]*$/) { # if a number
        return $value;
      } else { # anything else might as well be '0.0', whether N/A, kB or Bytes
        return 0.0;
      }
    }
  }
  return '';
}
#
# ---------------------------------------------------------------------------
#
# vmem maxvmem iow and ioops needs to run qstat -j
sub GetVMem    { return &GetJobInfo('vmem',@_);    }
sub GetMaxVMem { return &GetJobInfo('maxvmem',@_); }
sub GetIOWait  { return &GetJobInfo('iow',@_);     }
sub GetIOOPs   { return &GetJobInfo('ioops',@_);   }
#
# ---------------------------------------------------------------------------
#
sub Uptime {
  my $u;
  if ($option{fake}) {
      $u = '0.0';
      return $u;
  }
  #
  if ($#_ > -1) {
    my $h = shift(@_);
    my $cmd;
    if ($option{'uptime'} eq 'uptime') {
      $cmd = "ssh -x $h uptime";
    } else {
      $cmd = $option{'uptime'}." | grep $h";
    }
    $u = `$cmd`;
    $u =~ s/.* load //;
    $u =~ s/average://;
    # keep only the 1st value
    $u =~ s/, .*//;
  } else {
    $u = `uptime`;
    $u =~ s/.*://;
  }
  $u =~ s/ //g;
  chop($u);
  return $u;
}
#
# ---------------------------------------------------------------------------
#
sub bynode {
  my @wza = split('-',$a);
  my @wzb = split('-',$b);
  my $ax = $wza[0]*100+$wza[1];
  my $bx = $wzb[0]*100+$wzb[1];
  $ax <=> $bx;
}
